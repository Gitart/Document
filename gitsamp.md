В первую очередь необходимо поставить Git:

```git
pkg_add -r git
```
Затем создаем пару ssh ключей, если не создавали ее ранее:
```git
ssh-keygen
cat ~/.ssh/id_rsa.pub
```

Заходим на БитБакет, создаем git-репозиторий под новый проект, а в свойствах аккаунта прописываем свой открытый ssh-ключ. Затем клонируем репозиторий:
```git
cd ~/projects/haskell
git clone git@bitbucket.org:afiskon/hs-textgen.git
cd hs-textgen
```

Делаем какие-то изменения:
```git
echo test > TODO.TXT
```
Добавляем новый файл в репозиторий и делаем коммит:
```git
git add TODO.TXT
git commit -a
```
Поскольку я не указал описание коммита, запускается редактор VIM, с помощью которого я и ввожу описание. Затем я отправляю все сделанные мною изменения на БитБакет:
```git
git push origin
```

Допустим, теперь я хочу сделать некоторые изменения в проекте, но не уверен, выйдет ли из этого что-то хорошее. В таких случаях создается новая ветка:
```git
git branch new_feature
git checkout new_feature
```
Работаем с этой веткой. Если ничего хорошего не вышло, возвращаемся к основной ветке (она же «trunk» или «ствол»):
```git
git checkout master
```
Если вышло что-то хорошее, мержим ветку в master (о разрешении конфликтов рассказано в следующем параграфе):
```git
git commit -a # делаем коммит всех изменений в new_feature
git checkout master # переключаемся на master
git merge new_feature # мержим ветку new_feature
```
Не забываем время от времени отправлять наш код на BitBucket:
```git
git push origin
```
Если мы правим код с нескольких компьютеров, то перед началом работы не забываем «накатить» в локальный репозиторий последнюю версию кода:
```git
git pull origin
```
Работа в команде мало чем отличается от описанного выше. Только каждый программист должен работать со своей веткой, чтобы не мешать другим программистам. Одна из классических ошибок при начале работы с Git заключается в push’е всех веток, а не только той, с которой вы работали. Вообще я бы советовал первое время перед выполнением каждого push делать паузу с тем, чтобы подумать, что и куда сейчас уйдет. Для большей безопасности советую при генерации ssh-ключей указать пароль. Тогда каждый запрос пароля со стороны Git будет для вас сигналом «Эй, ты делаешь что-то, что затронет других».

Для работы с Git под Windows можно воспользоваться клиентом TortoiseGit. Если память не изменяет, для нормальной работы ему нужен MSysGit. Для генерации ключей можно воспользоваться утилитой PuTTyGen, только не забудьте экспортировать открытый ключ в правильном формате, «Conversions → Export OpenSSH key».

Следует отметить, что мне лично TortoiseGit показался каким-то глючноватым и вообще не слишком удобным. Возможно, это всего лишь дело привычки, но мне кажется намного удобнее работать с Git из консоли, чем с помощью контекстного меню в Проводнике. Так что по возможности я бы советовал работать с Git в Юниксах. В крайнем случае можно поставить виртуальную машину, установить под ней FreeBSD (безо всяких GUI) и работать в этой виртуальной машине.

## Шпаргалка по командам
В этом параграфе приведена сухая шпаргалка по командам Git. Я далеко не спец в этой системе контроля версий, так что ошибки в терминологии или еще в чем-то вполне возможны. Если вы видите в этом разделе ошибку, отпишитесь, пожалуйста, в комментариях.

Создать новый репозиторий:
```git
git init project-name
```

Если вы планируете клонировать его по ssh с удаленной машины, также скажите:
```git
git config --bool core.bare true
```

… иначе при git push вы будете получать странные ошибки вроде:

Refusing to update checked out branch: refs/heads/master
By default, updating the current branch in a non-bare repository
is denied, because it will make the index and work tree inconsistent
with what you pushed, and will require 'git reset --hard' to match
the work tree to HEAD.
Клонировать репозиторий с удаленной машины:

```git
git clone git@bitbucket.org:afiskon/hs-textgen.git
```

Если хотим пушить один код в несколько репозиториев:
```git
git remote add remotename git@gitlab.example.ru:repo.git
```

Добавить файл в репозиторий:
```git
git add text.txt
```
Удалить файл:
```git
git rm text.txt
```

Текущее состояние репозитория (изменения, неразрешенные конфликты и тп):
```git
git status
```
Сделать коммит:
```git
git commit -a -m "Commit description"
```

Сделать коммит, введя его описание с помощью $EDITOR:
```git
git commit -a
```
Замержить все ветки локального репозитория на удаленный репозиторий (аналогично вместо origin можно указать и remotename, см выше):
```git
git push origin
```
Аналогично предыдущему, но делается пуш только ветки master:
```git
git push origin master
```
Запушить текущую ветку, не вводя целиком ее название:
```git
git push origin HEAD
```
Замержить все ветки с удаленного репозитория:
```git
git pull origin
```
Аналогично предыдущему, но накатывается только ветка master:
```git
git pull origin master
```
Накатить текущую ветку, не вводя ее длинное имя:
```git
git pull origin HEAD
```
Скачать все ветки с origin, но не мержить их в локальный репозиторий:
```git
git fetch origin
```
Аналогично предыдущему, но только для одной заданной ветки:
```git
git fetch origin master
```
Начать работать с веткой some_branch (уже существующей):
```git
git checkout -b some_branch origin/some_branch
```
Создать новый бранч (ответвится от текущего):
```git
git branch some_branch
```
Переключиться на другую ветку (из тех, с которыми уже работаем):
```git
git checkout some_branch
```
Получаем список веток, с которыми работаем:
git branch # звездочкой отмечена текущая ветвь
Просмотреть все существующие ветви:

```git
git branch -a # | grep something
```
Замержить some_branch в текущую ветку:
```git
git merge some_branch
```
Удалить бранч (после мержа):
```git
git branch -d some_branch
```
Просто удалить бранч (тупиковая ветвь):
```git
git branch -D some_branch
```
История изменений:
```git
git log
```
История изменений в обратном порядке:
```git
git log --reverse
```
История конкретного файла:
```git
git log file.txt
```
Аналогично предыдущему, но с просмотром сделанных изменений:
```git
git log -p file.txt
```
История с именами файлов и псевдографическим изображением бранчей:
```git
git log --stat --graph
```
Изменения, сделанные в заданном коммите:
```git
git show d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4
```

Посмотреть, кем в последний раз правилась каждая строка файла:
```git
git blame file.txt
```
Удалить бранч из репозитория на сервере:
```git
git push origin :branch-name
```
Откатиться к конкретному коммиту (хэш смотрим в «git log»):
```git
git reset --hard d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4
```
Аналогично предыдущему, но файлы на диске остаются без изменений:
```git
git reset --soft d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4
```
Попытаться обратить заданный commit (но чаще используется branch/reset + merge):
```git
git revert d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4
```
Просмотр изменений (суммарных, а не всех по очереди, как в «git log»):
```git
git diff # подробности см в "git diff --help"
```
Используем vimdiff в качестве программы для разрешения конфликтов (mergetool) по умолчанию:
```git
git config --global merge.tool vimdiff
```
Отключаем диалог «какой mergetool вы хотели бы использовать»:
```git
git config --global mergetool.prompt false
```
Отображаем табы как 4 пробела, например, в «git diff»:
```git
git config --global core.pager 'less -x4'
```
Создание глобального файла .gitignore:
```git
git config --global core.excludesfile ~/.gitignore_global
```
Разрешение конфликтов (когда оные возникают в результате мержа):
```git
git mergetool
```
Создание тэга:
```git
git tag some_tag # за тэгом можно указать хэш коммита
```
Удаление untracked files:
```git
git clean -f
```
«Упаковка» репозитория для увеличения скорости работы с ним:
```git
git gc
```
Иногда требуется создать копию репозитория или перенести его с одной машины на другую. Это делается примерно так:
```git
mkdir -p /tmp/git-copy
cd /tmp/git-copy
git clone --bare git@example.com:afiskon/cpp-opengl-tutorial1.git
cd cpp-opengl-tutorial1.git
git push --mirror git@example.com:afiskon/cpp-opengl-tutorial2.git
```

Следует отметить, что Git позволяет использовать короткую запись хэшей. Вместо «d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4» можно писать «d8578edf» или даже «d857».

Дополнение: Также в 6-м пункте Мини-заметок номер 9 приводится пример объединения коммитов с помощью git rebase, а в 10-м пункте Мини-заметок номер 11 вы найдете пример объединения двух репозиториев в один без потери истории.

### Работа с сабмодулями
Более подробно сабмодули и зачем они нужны объясняется в заметке Простой кроссплатформенный OpenGL-проект на C++. Здесь упомянем самое главное.

Добавить сабмодуль:
```git
git submodule add https://github.com/glfw/glfw glfw
```
Инициализация сабмодулей:
```git
git submodule init
```
Обновление сабмодулей, например, если после git pull поменялся коммит, на который смотрит сабмодуль:
```git
git submodule update
```
Удаление сабмодуля производится так:

Скажите git rm --cached имя_сабмодуля;
Удалите соответствующие строчки из файла .gitmodules;
Также грохните соответствующую секцию в .git/config;
Сделайте коммит;
Удалите файлы сабмодуля;
Удалите каталог .git/modules/имя_сабмодуля;
