# REST API

***REST*** — это “Representational State Transfer”, другими словами — представление данных в удобном для клиента формате.

**REST** (Representational state transfer) изначально был задуман как простой и однозначный интерфейс для управления данными, предполагавший всего несколько базовых операций с непосредственным сетевым хранилищем (сервером): извлечение данных (GET), сохранение (POST), изменение (PUT/PATCH) и удаление (DELETE). Разумеется, этот перечень всегда сопровождался такими опциями, как обработка ошибок в запросе (корректно ли составлен запрос), разграничение доступа к данным (вдруг этого вам знать не следует) и валидация входящих данных (вдруг вы написали ерунду), в общем, всеми возможными проверками, которые сервер выполняет перед тем, как выполнить желание клиента.

Помимо этого REST имеет ряд архитектурных принципов, перечень которых можно найти в любой другой статье о REST. Пробежимся по ним кратко, чтобы они были под рукой, и не пришлось никуда уходить:

**Независимость сервера от клиента** – серверы и клиенты могут быть мгновенно заменены другими независимо друг от друга, так как интерфейс между ними не меняется. Сервер не хранит состояний клиента.

**Уникальность адресов ресурсов** – каждая единица данных (любой степени вложенности) имеет свой собственный уникальный URL, который, по сути, целиком является однозначным идентификатором ресурса.

Пример: GET /api/v1/users/25/name

**Независимость формата хранения данных от формата их передачи** – сервер может поддерживать несколько различных форматов для передачи одних и тех же данных (JSON, XML etc), но хранит данные в своем внутреннем формате, независимо от поддерживаемых.

**Присутствие в ответе всех необходимых метаданных** – помимо самих данных сервер должен возвращать детали обработки запроса, например, сообщения об ошибках, различные свойства ресурса, необходимые для дальнейшей работы с ним, например, общее число записей в коллекции для правильного отображения постраничной навигации. Мы еще пройдемся по разновидностям ресурсов.

## Для начала общие требования к default API:
* возможность расширения   
* удобный стандартизированный формат запросов   
* удобный стандартизированный формат ответов   
* достаточный уровень безопасности   
* возврат ошибок выполнения запроса    

## Клиент
Клиентом нашего API может быть как сервер (PHP/Perl/Python etс), так и UI (JS). Механизмы авторизации при этом будут несколько отличаться, но все остальное лучше стандартизировать.
После долгих тестов в реальной жизни я предпочел JSON. Я не имею ничего против XML, но очень часто приходится пользоваться функционалом API из JavaScript — почему бы и не использовать нативный формат?


## Структура запроса к серверу выглядит примерно так:
cmd="имя команды"&data="JSON объект"&sig="сигнатура запроса, используемая для аутентификации и проверки целостности запроса"

### По порядку:
cmd — ограниченный набор команд, обеспечивающий функционал. Например, auth, profile, edit, view и так далее — в зависимости от ваших потребностей. Этот параметр не передается в JSONе, чтобы не парсить JSON в случае отсутствия такой команды.    
data — передаваемая информация в JSONе.    
sig — сигнатура, обеспечивающая проверку правильности запроса и авторизацию. Например, при запросе сервер-сервер я использую следующий алгоритм: md5(cmd+secret+data), где secret — информация, известная обоим серверам (и нашему, и серверу клиента), но неизвестная более никому.    
При запросе сервер-клиент (AJAX-JavaScript) приходится использовать менее секурный вариант — secret хранится в cookie и меняется каждый сеанс.  


### Ответ:
```Json
{
  "status": "ok или error - удачность выполнения запроса"
 "response": "возвращаемые данные"
 "error": "код ошибки или 0 в случае удачи"
}
```

## Рассмотрим алгоритм работы серверной части:
Проверить, существует ли команда, соответствующая параметру cmd если да — то поверить сигнатуру(sig) — на этом этапе мы отметаем большую часть неумелых атак, еще не загружая сервер загрузить соответствующий модуль, реализующий функционал и передать ему данные
модуль делает свою работу — мы ему тут не нужны сформировать ответ с результатами работы модуля или кодом ошибки и вернуть его клиенту


## Посмотрим на классы, которые сформировались за несколько подобных систем и теперь мигрируют из одной в другую:

**Manager** — проверяет существование команды и правильность сигнатуры, проверяет правильность данных на входе и отправляет ошибки о не корректных данных   
**Module** — каждый объект этого класса описывает определенный модуль. Описание состоит из названия, списка необходимых для работы файлов, которые будут включены при запуске модуля, список параметров, которые он будет брать у объекта Registry, список параметров, без которых его не запускать, а сразу выдавать ошибку   
**Registry** — синглтон, в честь одноименного шаблона — заворачивает в себя входящие данные под чутким руководством объекта Manager. Позже именно к нему будут обращаться модули за данными   
**Response** — синглтон, строит ответ из данных, полученных от модуля. Именно в нем мы кодируем ответ в нужный нам формат (JSON в данном случае)   

## Класс-обертка к БД по вкусу
Таким образом, модули можно писать хоть процедурные — все данные они берут из объекта Registry и возвращают в объект Response.

## Стандартные модули, которые встречаются почти в каждой системе:
**auth** — открытие соединения с API   
**log_out** — собственно закрытие соединения   
**user** — вывод информации о пользователе   
**view** — просмотр одной записи   
**list** — просмотр списка записей   
**add** — добавление записи   
**edit** — редактирование записи   
**del** — удаление записи   



## 1. Синтаксис запроса
Чтобы обратиться к методу API ВКонтакте, Вам необходимо выполнить POST или GET запрос такого вида:
https://host:port/method/METHOD_NAME?PARAMETERS&access_token=ACCESS_TOKEN&v=V 

## Он состоит из нескольких частей:
**METHOD_NAME** (обязательно)  — название метода API, к которому Вы хотите обратиться. Полный список методов доступен на этой странице.
**PARAMETERS** (опционально)   — входные параметры соответствующего метода API, последовательность пар name=value, разделенных амперсандом. Список параметров указан на странице с описанием метода.
**ACCESS_TOKEN** (опционально) — ключ доступа. Подробнее о получении токена Вы можете узнать в этом руководстве.

Параметры могут передаваться как методом GET, так и POST. Если вы будете передавать большие данные (больше 2 килобайт), следует использовать POST. 


[Общее количество модулей в системе не влияют на ее производительность, так что полет вашей фантазии в области функционала не ограничен.](https://habrahabr.ru/post/108973/)  

## Technology
[REST](https://ru.wikipedia.org/wiki/REST)   
[AUTH](https://developers.google.com/identity/protocols/OAuth2)   
[REST](https://en.wikipedia.org/wiki/Representational_state_transfer#Applied_to_web_services)   
[JSON](https://en.wikipedia.org/wiki/JSON)   
[Http](https://www.w3.org/Protocols/rfc2616/rfc2616.html)  
[Микросервисы)(https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D1%8B)  


